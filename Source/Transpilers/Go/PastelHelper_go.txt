
// PASTEL_ENTITY_ID: PST_ExtCallbacks
type ExtFunc func(array []any) any
var PST_ExtCallbacks map[string]ExtFunc = make(map[string]ExtFunc, 0) 

// PASTEL_ENTITY_ID: PST_RegisterExtensibleCallback
func PST_RegisterExtensibleCallback(name *string, fn ExtFunc) {
  PST_ExtCallbacks[*name] = fn
}

// PASTEL_ENTITY_ID: PST_SortedIntArrayCopy
func PST_SortedIntArrayCopy(nums []int) []int {
  copied := nums[:]
  sort.Ints(copied)
  return copied
}

// PASTEL_ENTITY_ID: PST_intToStr
func PST_intToStr(n int) *string {
  s := strconv.Itoa(n)
  return &s
}

// PASTEL_ENTITY_ID: PST_strPtr
func PST_strPtr(s string) *string {
  return &s
}

// PASTEL_ENTITY_ID: PST_listJoin
func PST_listJoin(list *plist, sep *string) *string {
  items := list.items
  sz := len(items)
  i := 0
  sb := make([]string, sz)
  for i < sz {
    sb[i] = *items[i].(*string)
    i += 1
  }
  o := strings.Join(sb, *sep)
  return &o
}

// PASTEL_ENTITY_ID: PST_newList
func PST_newList(sz int) *plist {
  o := new(plist)
  o.items = make([]any, sz)
  return o
}

// PASTEL_ENTITY_ID: PST_strEq
func PST_strEq(a *string, b *string) bool {
  return a == b || (a != nil && b != nil && *a == *b)
}

// PASTEL_ENTITY_ID: PST_strToUtf8Bytes
func PST_strToUtf8Bytes(a *string) *plist {
  buf := []byte(*a)
  sz := len(buf)
  arr := make([]any, sz)
  i := 0
  for i < sz {
    arr[i] = int(buf[i])
    i += 1
  }
  o := new(plist)
  o.items = arr
  return o
}

// PASTEL_ENTITY_ID: PST_strTrim
func PST_strTrim(s *string, mask int) *string {
  cut := " \r\n\t　";
  o := "";
  if mask == 3 {
    o = strings.Trim(*s, cut);
  } else if mask == 1 {
    o = strings.TrimRight(*s, cut);
  } else {
    o = strings.TrimLeft(*s, cut);
  }
  return &o;
}

// PASTEL_ENTITY_ID: PST_utf8BytesToStr
func PST_utf8BytesToStr(arr []any) *string {
  sz := len(arr)
  b_arr := make([]byte, sz)
  i := 0
  for i < sz {
    b_arr[i] = arr[i].(byte)
  }
  s := string(b_arr)
  return &s
}

// PASTEL_ENTITY_ID: PST_strReverse
func PST_strReverse(s *string) *string {
  src := PST_strToUtf8Bytes(s).items
  sz := len(src)
  dst := make([]byte, sz)
  src_i := 0
  dst_i := sz
  for src_i < sz {
    b := src[src_i].(int)
    char_sz := 1
    if b >= 128 {
      if (b & 0xE0) == 0xC0 {
        char_sz = 2
      } else if (b & 0xF0) == 0xE0 {
        char_sz = 3
      } else if (b & 0xF8) == 0xF0 {
        char_sz = 4
      } else {
        panic("Invalid UTF-8 string")
      }
    }
    dst_i -= char_sz
    j := 0
    for j < char_sz {
      dst[dst_i+j] = byte(src[src_i+j].(int))
      j += 1
    }
    src_i += char_sz
  }
  o := string(dst)
  return &o
}
